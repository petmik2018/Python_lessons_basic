# Задание-1:
# Матрицы в питоне реализуются в виде вложенных списков:
# Пример. Дано:
matrix = [[1, 0, 8],
          [3, 4, 1],
          [0, 4, 2]]
          
# Выполнить поворот (транспонирование) матрицы
# Пример. Результат:
# matrix_rotate = [[1, 3, 0],
#                  [0, 4, 4],
#                  [8, 1, 2]]

# Суть сложности hard: Решите задачу в одну строку

for elem in list(zip(*matrix)): print(" "*len("matrix_rotate = ") if list(zip(*matrix)).index(elem) else "matrix_rotate = ", elem)


# Задание-2:
# Найдите наибольшее произведение пяти последовательных цифр в 1000-значном числе.
# Выведите произведение и индекс смещения первого числа последовательных 5-ти цифр.
# Пример 1000-значного числа:

# Пришлось удалить перенос строки из записи числа
# если успею разобраться, внесу изменения в решение

number = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"

print(number)

mult_max = 0
i_max = -1
for i in range (0,(len(number)-4)):
    mult = 1
    for j in range(0,5): mult = mult * int(number[i+j])
    if mult > mult_max:
        mult_max = mult
        i_max = i

print("Смещение: {}, произведение: {}, цифры: {}".format(i_max, mult_max, number[i_max:(i_max+5)]))


# Задание-3 (Ферзи):
# Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били
# друг друга. Вам дана расстановка 8 ферзей на доске.
# Определите, есть ли среди них пара бьющих друг друга.
# Программа получает на вход восемь пар чисел,
# каждое число от 1 до 8 — координаты 8 ферзей.
# Если ферзи не бьют друг друга, выведите слово NO, иначе выведите YES.

#-------------------первый способ, чистая математика----------------
# простой попарный перебор фигур
# фиксирую для формальной сдачи ДЗ, но пытаюсь найти другое решение


figures = [[2, 3], [3, 4], [1, 8], [1, 5], [7, 1], [5, 7], [6, 2], [8, 6]]

def check_connection(a, b):
    return a[0] == b[0] or a[1] == b[1] or a[0]-b[0] == a[1]-b[1] or b[0]-a[0] == a[1]-b[1]

result = "NO"
for i in range(0, 7):
    for j in range (i+1, 8):
        if check_connection(figures[i], figures[j]):
            result = "YES"
print(result)

# -------альтернативный вариант решения, в один проход по списку
# тоже чистая математика. Как привлечь к решению тему урока, не придумал

horisontal = [0 for _ in range(0,9)] # индикатор ферзей на одной горизонтали
vertical = [0 for _ in range(0,9)] # индикатор ферзей на одной вертикали
diagonal_right = [0 for _ in range(0,15)] # индикатор ферзей на "правых" диагоналях
# для фигур на одной "правой" диагонали совпадают разности координат (от -7 до 7)
diagonal_left = [0 for _ in range(0,15)] # индикатор ферзей на "левых" диагоналях
# для фигур на одной "правой" диагонали совпадают суммы координат (от 2 до 16)

for ferz in figures: # при попадании фигуры на линию индикатор увеличивается на 1
    horisontal[ferz[0]] += 1
    vertical[ferz[1]] += 1
    diagonal_right[(ferz[1]-ferz[0] + 7)] += 1
    diagonal_left[(ferz[1]+ferz[0] - 2)] += 1
    
result = "NO"
if max(horisontal) > 1: result = "YES"
if max(vertical) > 1: result = "YES"
if max(diagonal_right) > 1: result = "YES"
if max(diagonal_left) > 1: result = "YES"

print(result